# 类2

## 魔术方法

我们继续讨论类的另一个概念--魔术方法。在[类1](https://github.com/im-iron-man/python-gramma/blob/master/7.md)中，我们见到了python最基本的魔术方法：\_\_init\_\_，其作用是初始化类（即实例化类）。除此以外，python还有许多其他的魔术方法，具体可参见[Python魔术方法指南](http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html)。

下面是有关魔术方法的一些基本概念：

- 魔术方法是python内置的；
- 大部分魔术方法以两个下划线开头，以两个下划线结尾；
- 在python2中，next方法不要下划线；在python3中，__next__方法要下划线；
- 在类中实现一个魔术方法，或者一系列魔术方法将会收到奇效。

## \_\_str\_\_, \_\_repr\_\_

首先，介绍一下两者的作用和用法：

- \_\_str\_\_：强调对象代表的东西，在交互式中使用`>>> print 对象`，会自动调用str(对象)；
- \_\_repr\_\_：强调对象本身，在交互式中使用`>>> 对象`，会自动调用repr(对象)。

比如，使用python标准库中的datetime.date：

```
>>> from datetime import date
>>> d = date(2017, 10, 3)
>>> print d
2017-10-03
>>> str(d)
'2017-10-03'
>>> d
datetime.date(2017, 10, 3)
>>> repr(d)
'datetime.date(2017, 10, 3)'
```

其次，我们自己写一个实现了这两个方法的类：

```python
class Add(object):

    def __init__(self, i, j):
        self.i = i
        self.j = j
    
    def __str__(self):
        return str(self.i + self.j)
    
    def __repr__(self):
        return '{i} + {j}'.format(i=self.i, j=self.j)
	
a = Add(1, 2)
print str(a)
print repr(a)
```

## \_\_len\_\_, \_\_nonzero\_\_

python中的对象可以用内建函数bool来判断布尔值是True还是False，如下

```
>>> bool(1)
True
>>> bool(0)
False
>>> bool(True)
True
>>> bool(False)
False
>>> def f(a):
        return a
>>> bool(f)
True
>>> bool(__builtins__)
True
>>> import collections
>>> bool(collections)
True
```

类似魔术方法\_\_str\_\_, \_\_repr\_\_，在使用`if 对象`或者`while 对象`时，会自动调用bool(对象)。

下面讨论一下内建函数bool和魔术方法\_\_len\_\_, \_\_nonzero\_\_的关系：

- 如果对象没有实现__nonzero__方法或者__len_方法，bool函数返回True；
- 如果对象实现了__nonzero__方法，根据__nonzero__方法的返回值判断；
- 如果对象没有实现__nonzero__方法，但实现了__len__方法，根据__len__方法的返回值判断。

```python 
class f(object):
    """without __nonzero__ and __len__"""

    def __init__(self, a, b):
        self.a = a
        self.b = b

t = f(0,1)
print bool(t) # True
```

```python
class f(object):
    """with __nonzero__"""

    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __nonzero__(self):
        return self.a
	
    def __len__(self):
        return self.b
	
t = f(0,1)
print bool(t) # False
```

```python
class f(object):
    """with __len__"""

    def __init__(self, a, b):
        self.a = a
        self.b = b
	
    def __len__(self):
        return self.b
	
t = f(1,0)
print bool(t) # False
```

## 容器

先列举几个与容器相关的概念：

```
生成器--->迭代器--->可迭代对象--->容器
```

其中`--->`表示包含于的意思。

### 容器

容器是指能使用`_ in 对象`或者`for _ in 对象`的对象，比如set, tuple, list, dict, str。我们看下面这个类：

```python
class Container(object):
    """use __setitem__ and __getitem__
    implement a container
    """
    
    def __init__(self):
        self.k = []
        self.v = []
		
    def __setitem__(self, k, v):
        """>>> self[k] = v"""
        self.k.append(k)
        self.v.append(v)
    
    def __getitem__(self, k):
        """>>> print self[k]"""
        try:
            i = self.k.index(k)
            return self.v[i]
        except:
            raise IndexError('invalid index')

####################
# test:            #
# __setitem__      #
# __getitem__      #
####################
c = Container()
c[0] = 'a'
c[1] = 'b'
c[2] = 'c'
c[3] = 'd'
c[1] = 'e'
print c[0]
print c[1]
print c[2]
print c[3]

#####################
# test:             #
# in                #
#####################
print 'a' in c
print 'b' in c
print 'c' in c
print 'd' in c
print 'e' in c
for x in c:
    print x
```

所以当类实现了魔术方法__getitem__时，使用in，逻辑如下：

- `print 'b' in c`：

```python
def in_func(x, X):
    try:
        i = 0
        while True:
            if x == X[i]:
                return True
            i += 1
    except IndexError:
        return False

print in_func('a', c) # 'a' in c
print in_func('b', c) # 'b' in c
print in_func('c', c) # 'c' in c
print in_func('d', c) # 'd' in c
print in_func('e', c) # 'e' in c
```

- `for x in c: print x`：

```python
try:
    i = 0
    while True:
        print c[i]
        i += 1
except IndexError:
    pass
```

除了__getitem__可以实现容器外，还有许多其他的魔术方法，比如__iter__，next。

### 可迭代对象

### 迭代器

### 生成器

## 运算符重载

## 可调用对象